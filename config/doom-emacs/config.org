#+title: config.org
#+startup: fold
#+property: header-args:emacs-lisp :results silent

* Base

#+begin_src emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Constants

Let's define some constants we'll use throughout our configuration. Yeah, Doom
already define those, but we want to keep all constants as ~*<name>*~.

*** Operating System

#+begin_src emacs-lisp
(defconst *is-macos* IS-MAC)
(defconst *is-linux* IS-LINUX)
#+end_src

*** Emacs version

#+begin_src emacs-lisp
(defconst *is-emacs-28* EMACS28+)
(defconst *is-emacs-29* EMACS29+)
#+end_src

** Performance

*** Update UI less frequently.

#+begin_src emacs-lisp
(setq idle-update-delay 1.0
      jit-lock-defer-time 0)
#+end_src

*** Pixel scroll

In Emacs > 29, we can use Po Lu's ~pixel-scroll-precision-mode~ to get a faster
and better scrolling.

#+begin_src emacs-lisp
(when *is-emacs-29*
    (pixel-scroll-precision-mode))
#+end_src

** Behavior
*** UTF-8 by default

Emacs is very conservative about assuming encoding. Everything is utf-8 these days,
lets have that as the default.

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
(set-clipboard-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)
#+end_src

*** Final EOL
Always set a EOL at the end of files.

#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src

* Behavior
** Formatting (=apheleia=)
The current Doom =:editor format= module is not good and causes a lot of issues,
they want to replace the current implementation with [[https://github.com/radian-software/apheleia][apheleia]]. This part of the config
creates a replacement that we can use now.

First, we install the package itself.

#+begin_src emacs-lisp :tangle modules/editor/format/packages.el
(package! apheleia
  :recipe (:host github :repo "radian-software/apheleia"))
#+end_src

*** Configuration

Some helper variables that we will use throughout the configuration.

#+begin_src emacs-lisp :tangle modules/editor/format/config.el
;;; editor/format/config.el -*- lexical-binding: t; -*-

(defvar +format-preserve-indentation t
  "If non-nil, the leading indentation is preserved when formatting the whole
 buffer. This is particularly useful for partials.

Indentation is always preserved when formatting regions.")

(defvar +format-with-lsp t
  "If non-nil, format with LSP formatter if it's available.

This can be set buffer-locally with `setq-hook!' to disable LSP formatting in
selected buffers.")

(defvaralias '+format-with 'apheleia-formatter
  "Set this to explicitly use a certain formatter for the current buffer.")
#+end_src

Enable formatting on-save if =+onsave= is enabled.

#+begin_src emacs-lisp :tangle modules/editor/format/config.el
(when (featurep! +onsave)
  (add-hook 'doom-first-file-hook #'apheleia-global-mode))
#+end_src

Fix integration between =apheleia= and some modes.

#+begin_src emacs-lisp :tangle modules/editor/format/config.el
(defadvice! +format--inhibit-reformat-on-prefix-arg-a (orig-fn &optional arg)
  "Make it so \\[save-buffer] with prefix arg inhibits reformatting."
  :around #'save-buffer
  (let ((apheleia-mode (and apheleia-mode (member arg '(nil 1)))))
    (funcall orig-fn)))

(add-hook! 'apheleia-post-format-hook
  ;; HACK `web-mode' doesn't update syntax highlighting after arbitrary buffer
  ;;      modifications, so we must trigger refontification manually.
  (defun +format--fix-web-mode-fontification-h ()
    (when (eq major-mode 'web-mode)
      (setq web-mode-fontification-off nil)
      (when (and web-mode-scan-beg web-mode-scan-end global-font-lock-mode)
        (save-excursion
          (font-lock-fontify-region web-mode-scan-beg web-mode-sacn-end)))))
  (defun +format--refresh-git-gutter-h ()
    (when (bound-and-true-p git-gutter-mode)
      (git-gutter))))
#+end_src

Now we replace the =+format/*= functions to use our module.

First, the logic to format a specific region.
#+begin_src emacs-lisp :tangle modules/editor/format/autoload/format.el
;;; editor/format/autoload.el -*- lexical-binding: t; -*-

(defun +format--current-indentation ()
  (save-excursion
    (goto-char (point-min))
    (skip-chars-forward " \t\n")
    (current-indentation)))

(defun +format-region (start end &optional callback)
  "Format from START to END with `apheleia'."
  (when-let* ((command (apheleia--get-formatter-command
                        (if current-prefix-arg
                            'prompt
                         'interactive)))
              (cur-buffer (current-buffer))
              (formatted-buffer (get-buffer-create " *apheleia-formatted*"))
              (indent 0))
    (with-current-buffer formatted-buffer
      (erase-buffer)
      (setq-local coding-system-for-read 'utf-8)
      (setq-local coding-system-for-write 'utf-8)
      ;; Ensure this temp buffer seems as much like the origin buffer as
      ;; possible, in case the formatter is an elisp function, like `gofmt'.
      (cl-loop for (var . val)
               in (cl-remove-if-not #'listp (buffer-local-variables origin-buffer))
               ;; Making enable-multibyte-characters buffer-local causes
               ;; an error.
               unless (eq var 'enable-multibyte-characters)
               do (set (make-local-variable var) val))
      (insert-buffer-substring-no-properties cur-buffer start end)
      ;; Since we're piping a region to the formatter, remove any leading
      ;; indentation to make it look like a file.
      (setq indent (+format--current-indentation))
      (when (> indent 0)
        (indent-rigidly (point-min) (point-max) (- indent)))
      (apheleia-format-buffer
       command
       (lambda ()
         (with-current-buffer formatted-buffer
           (when (> indent 0)
             ;; restore indentation without affecting new indentation
             (indent-rigidly (point-min) (point-max)
                             (max 0 (- indent (+format--current-indentation))))))
         (with-current-buffer cur-buffer
           (delete-region start end)
           (insert-buffer-substring-no-properties formatted-buffer)
           (when callback (funcall callback))
           (kill-buffer formatted-buffer)))))))
#+end_src

Now, the high-level functions that Doom uses.
#+begin_src emacs-lisp :tangle modules/editor/format/autoload/format.el
(defun +format--use-lsp? (feature)
  "Return non-nil if we should use the LSP formatter for the specifi FEATURE."
  (and +format-with-lsp
       (bound-and-true-p lsp-mode)
       (lsp-feature? feature)))

;;;###autoload
(defun +format/buffer (&optional arg)
  "Reformat the current buffer using LSP or `format-all-buffer'."
  (interactive)
  (call-interactively
    (if (+format--use-lsp? "textDocument/formatting")
        #'lsp-format-buffer
      #'apheleia-format-buffer)))

;;;###autoload
(defun +format/region (beg end &optional arg)
  "Runs the active formatter on the lines within BEG and END.

WARNING: this may not work everywhere. It will throw errors if the region
contains a syntax error in isolation. It is mostly useful for formatting
snippets or single lines."
  (interactive "rP")
  (if (+format--use-lsp? "textDocument/rangeFormatting")
      (call-interactively #'lsp-format-region)
    (+format-region beg end)))

;;;###autoload
(defun +format/region-or-buffer ()
  "Runs the active formatter on the selected region (or whole buffer, if nothing
 is selected)."
  (interactive)
  (call-interactively
    (if (doom-region-active-p)
        #'+format/region
      #'+format/buffer)))
#+end_src

#+begin_src emacs-lisp :tangle modules/editor/format/autoload/settings.el
;;; editor/format/autoload/settings.el -*- lexical-binding: t; -*-

;;;###autodef
(cl-defun set-formatter!
    (name formatter &key modes filter ok-statuses error-regexp)
  "Define (or modify) a formatter named NAME."
  (declare (indent defun))
  (message "Not implemented yet"))
#+end_src

Not all the default formatters provided by =apheleia= are what we want to use. This
part of the configuration replace them with what we want.

#+begin_quote
Note that these are not inside the module, but in our configuration.
#+end_quote

#+begin_src emacs-lisp
(after! apheleia
  ;; Also use `isort' for python.
  (setf (alist-get 'isort apheleia-formatters)
        '("isort" "--stdout" "-"))
  (setf (alist-get 'python-mode apheleia-mode-alist)
        '(isort black))
  ;; Use `alejandra' for Nix instead of `nixfmt'.
  (setf (alist-get 'alejandra apheleia-formatters)
        '("alejandra" "--threads" "1" "--quiet"))
  (setf (alist-get 'nix-mode apheleia-mode-alist)
        '(alejandra)))
#+end_src

** Lints (=flycheck=)

*** Inline diagnostics
Doom uses popups for =flycheck='s diagnostics. This works fine in most languages but is not
ideal for Rust, as it provides notes in other lines that are important to understand what is going
on. A better solution, then, is to use =flycheck-inline=.

First, we install =quick-peek= and =flycheck-inline=:

#+begin_src emacs-lisp :tangle packages.el
(package! quick-peek
          :recipe (:host github
                   :repo "cpitclaudel/quick-peek"
                   :files ("quick-peek.el")))

(package! flycheck-inline
          :recipe (:host github
                   :repo "flycheck/flycheck-inline"
                   :files ("flycheck-inline.el")))
#+end_src

Then, we override what doom does:

#+begin_src emacs-lisp :tangle packages.el
(package! flycheck-popup-tip :disable t)
(package! flycheck-posframe :disable t)
#+end_src

Now, we instruct =lsp-mode= to add a group to the flycheck error, while also storing the
diagnostics' related information, which we should also show.

#+begin_src emacs-lisp
(defvar-local +lsp-diagnostics--flycheck-error-related-information (make-hash-table))

(defun lsp-diagnostics--flycheck-start (checker callback)
  "Start an LSP syntax check with CHECKER.

CALLBACK is the status callback passed by Flycheck."

  (remove-hook 'lsp-on-idle-hook #'lsp-diagnostics--flycheck-buffer t)
  (setq +lsp-diagnostics--flycheck-error-related-errors (make-hash-table))

  (->> (lsp--get-buffer-diagnostics)
       (-map
        (-lambda ((&Diagnostic :message :severity? :tags? :code? :source? :related-information?
                               :range (&Range :start (&Position :line      start-line
                                                                :character start-character)
                                              :end   (&Position :line      end-line
                                                                :character end-character))))
          (let* ((group (gensym)))
            (puthash group related-information?
                     +lsp-diagnostics--flycheck-error-related-information)
            (flycheck-error-new
                   :buffer (current-buffer)
                   :checker checker
                   :filename buffer-file-name
                   :message message
                   :level (lsp-diagnostics--flycheck-calculate-level severity? tags?)
                   :id code?
                   :group group
                   :line (lsp-translate-line (1+ start-line))
                   :column (1+ (lsp-translate-column start-character))
                   :end-line (lsp-translate-line (1+ end-line))
                   :end-column (1+ (lsp-translate-column end-character))))))
       (funcall callback 'finished)))
#+end_src

Finally, we configure the new interface:

#+begin_src emacs-lisp
(require 'quick-peek)

(defun +flycheck-inline-display-function--should-show ()
  (if evil-local-mode
      (eq evil-state 'normal)
    (not (bound-and-true-p company-backend))))

(defun +flycheck-inline-display-function--overlay-offset (pos)
  (let* ((col (1- (cdr (flycheck-line-column-at-pos pos))))
         (beg (- pos col))
         (overlays-offset (->> (overlays-in beg (1+ pos))
                               (--filter (<= (overlay-end it) pos))
                               (--map (overlay-get it 'before-string))
                               (--filter it)
                               (-map #'string-bytes)
                               -sum)))
    (+ col overlays-offset)))

(defun +flycheck-inline-display-function--show-overlay (msg pos)
  (let* ((overlay (quick-peek-overlay-ensure-at pos))
         (contents (quick-peek-overlay-contents overlay))
         (offset (+flycheck-inline-display-function--overlay-offset pos))
         (indented-msg (flycheck-inline-indent-message offset msg))
         (new-contents (concat contents (when contents "\n") indented-msg)))
    (setf (quick-peek-overlay-contents overlay) new-contents)
    (quick-peek-update overlay)))

(defun +flycheck-inline-display-function--with-lsp (err)
  (let ((filename (-> err flycheck-error-filename lsp--fix-path-casing))
        (related-info (gethash (flycheck-error-group err)
                               +lsp-diagnostics--flycheck-error-related-information
                               'not-found)))
    (unless (eq related-info 'not-found)
      (map-do
       (-lambda ((&DiagnosticRelatedInformation
                  :message
                  :location (&Location :range (&Range :start (&Position :line start-line
                                                                          :character start-character)
                                                      :end (&Position :line end-line
                                                                      :character end-character))
                                       :uri)))
           (let* ((line (lsp-translate-line (1+ start-line)))
                  (column (1+ (lsp-translate-column start-character)))
                  (eline (lsp-translate-line (1+ end-line)))
                  (ecolumn (1+ (lsp-translate-column end-character)))
                  (beg (flycheck-line-column-to-position line column))
                  (end (flycheck-line-column-to-position eline ecolumn))
                  (pos (cond
                        ((< beg end) beg)
                        ((= end (point-max)) (1- end))
                        (t (1+ end))))
                  (msg (propertize message 'face 'flycheck-inline-info)))
             (when (equal (-> uri lsp--uri-to-path lsp--fix-path-casing)
                          filename)
               (+flycheck-inline-display-function--show-overlay msg pos))))
       related-info))))

(defun +flycheck-inline-display-function--peek (msg pos err)
  (when (+flycheck-inline-display-function--should-show)
    (+flycheck-inline-display-function--show-overlay msg pos)
    (+flycheck-inline-display-function--with-lsp err)))

(use-package! flycheck-inline
  :hook (flycheck-mode . flycheck-inline-mode)
  :config
  (setq flycheck-inline-display-function #'+flycheck-inline-display-function--peek
        flycheck-inline-clear-function #'quick-peek-hide
        ;; Doesn't work correctly with diplay-line-numbers
        quick-peek-add-spacer nil)

  (custom-set-faces!
    `(quick-peek-background-face :background ,(doom-color 'base1)))

  (add-hook! '(evil-insert-state-entry-hook evil-replace-state-entry-hook)
             #'quick-peek-hide))
#+end_src

** Language Server Protocol (LSP)

Although Doom already handles a bunch of stuff for us, we need to change some
things.

First, we install everything via Nix, so =lsp-mode= don't need to asks us anything.

#+begin_src emacs-lisp
(setq lsp-enable-suggest-server-download nil)
#+end_src

Then, we unpin the package version.

#+begin_src emacs-lisp :tangle packages.el
(package! lsp-mode :pin nil)
#+end_src

Now, we improve the performance of =lsp-mode=.

#+begin_src emacs-lisp
(setq lsp-use-plists t
      lsp-idle-delay 0.500
      read-process-output-max (* 10 1024 1024))
#+end_src

*** Hover
#+begin_src emacs-lisp
(setq lsp-ui-doc-position 'at-point
      lsp-ui-doc-delay 0.5
      lsp-ui-doc-show-with-cursor t
      lsp-ui-doc-show-with-mouse t)
#+end_src

*** Semantic Highlighting
First, enable the feature.
#+begin_src emacs-lisp
(setq lsp-semantic-tokens-enable t
      lsp-semantic-tokens-honor-refresh-requests nil)
#+end_src

Now, we have to fix a problem in the current =lsp-mode= implementation: it is not
possible to define a face for a specific pair $(token, modifier)$, as can be
done in VSCode.
This causes problems as some languages /need/ this functionality to be properly
highlighted. As an example, in Rust, with the default configuration, both the ~async~
keyword and ~async fn~ /function names/ will have the same face, always.

#+begin_src emacs-lisp
(defvar lsp-semantic-token-modifier-pair-faces
  '()
  "An association list that contains faces to be applied to specific
pairs of token <> modifier.

The list is expected to have the format (major-mode -> token -> modifier -> face),
that is, it should be an association list of association lists.")

(defun +lsp-semantic-tokens-build-pair-alist (faces modifier-faces)
  "Builds an association list for each pair in `lsp-semantic-token-modifier-pair-faces',
in a way that can be directly used by `lsp-semantic-token--fontify'.

Each pair is represented as a key (+ (* <idx in faces> (length modifier-faces)) <idx in modifier-faces>).

This has O(n*m) complexity, so it should be called only once by request.
"
  (setq pair-faces '()
        mod-faces-length (length modifier-faces)
        major-mode-faces (assq major-mode lsp-semantic-token-modifier-pair-faces))
  (cl-loop for idx-f from 0 to (1- (length faces)) do
    (when-let* ((face (aref faces idx-f))
                (token-name (car (rassoc face lsp-semantic-token-faces)))
                (token-faces (cdr (assoc token-name major-mode-faces))))
        (cl-loop for idx-m from 0 to (1- mod-faces-length) do
          (when-let* ((mod-face (aref modifier-faces idx-m))
                      (mod-name (car (rassoc mod-face lsp-semantic-token-modifier-faces)))
                      (idx (+ (* idx-f mod-faces-length) idx-m))
                      (face (cdr (assoc mod-name token-faces))))
            (setf (alist-get idx pair-faces) face)))))
  pair-faces)

(defun +lsp-semantic-tokens--fontify-with-pairs (old-fontify-region beg-orig end-orig &optional loudly)
  ;; TODO: support multiple language servers per buffer?
  (let ((faces (seq-some #'lsp--workspace-semantic-tokens-faces lsp--buffer-workspaces))
        (modifier-faces
         (when lsp-semantic-tokens-apply-modifiers
           (seq-some #'lsp--workspace-semantic-tokens-modifier-faces lsp--buffer-workspaces)))
        old-bounds
        beg end)
    (cond
     ((or (eq nil faces)
          (eq nil lsp--semantic-tokens-cache)
          (eq nil (plist-get lsp--semantic-tokens-cache :response)))
      ;; default to non-semantic highlighting until first response has arrived
      (funcall old-fontify-region beg-orig end-orig loudly))
     ((not (= lsp--cur-version (plist-get lsp--semantic-tokens-cache :_documentVersion)))
      ;; delay fontification until we have fresh tokens
      '(jit-lock-bounds 0 . 0))
     (t
      (setq old-bounds (funcall old-fontify-region beg-orig end-orig loudly))
      ;; this is to prevent flickering when semantic token highlighting
      ;; is layered on top of, e.g., tree-sitter-hl, or clojure-mode's syntax highlighting.
      (setq beg (min beg-orig (cadr old-bounds))
            end (max end-orig (cddr old-bounds)))
      ;; if we're using the response to a ranged request, we'll only be able to fontify within
      ;; that range (and hence shouldn't clear any highlights outside of that range)
      (let ((token-region (plist-get lsp--semantic-tokens-cache :_region)))
        (if token-region
            (progn
              (lsp--semantic-tokens-putcache :_truncated (or (< beg (car token-region))
                                                             (> end (cdr token-region))))
              (setq beg (max beg (car token-region)))
              (setq end (min end (cdr token-region))))
          (lsp--semantic-tokens-putcache :_truncated nil)))
      (-let* ((inhibit-field-text-motion t)
              (data (lsp-get (plist-get lsp--semantic-tokens-cache :response) :data))
              (i0 0)
              (i-max (1- (length data)))
              (current-line 1)
              (line-delta)
              (column 0)
              (face)
              (line-start-pos)
              (line-min)
              (line-max-inclusive)
              (text-property-beg)
              (text-property-end))
        (save-mark-and-excursion
          (save-restriction
            (widen)
            (goto-char beg)
            (goto-char (line-beginning-position))
            (setq line-min (line-number-at-pos))
            (with-silent-modifications
              (goto-char end)
              (goto-char (line-end-position))
              (setq line-max-inclusive (line-number-at-pos))
              (forward-line (- line-min line-max-inclusive))
              (let ((skip-lines (- line-min current-line)))
                (while (and (<= i0 i-max) (< (aref data i0) skip-lines))
                  (setq skip-lines (- skip-lines (aref data i0))
                        i0 (+ i0 5)))
                (setq current-line (- line-min skip-lines)))
              (forward-line (- current-line line-min))
              (setq line-start-pos (point))
              (setq pair-faces (+lsp-semantic-tokens-build-pair-alist faces modifier-faces))
              (cl-loop
               for i from i0 to i-max by 5 do
               (setq line-delta (aref data i))
               (unless (= line-delta 0)
                 (forward-line line-delta)
                 (setq line-start-pos (point)
                       column 0
                       current-line (+ current-line line-delta)))
               (setq column (+ column (aref data (1+ i)))
                     face-idx (aref data (+ i 3))
                     face (aref faces face-idx)
                     text-property-beg (+ line-start-pos column)
                     text-property-end (+ text-property-beg (aref data (+ i 2))))
               (when face
                 (put-text-property text-property-beg text-property-end 'face face))
               ;; Deal with modifiers. We cache common combinations of modifiers,
               ;; storing the faces they resolve to.
               (let* ((modifier-code (aref data (+ i 4)))
                      (faces-to-apply (gethash modifier-code semantic-token-modifier-cache 'not-found)))
                 (when (eq 'not-found faces-to-apply)
                   (setq faces-to-apply nil)
                   (cl-loop for j from 0 to (1- (length modifier-faces)) do
                            (when (and (aref modifier-faces j)
                                    (> (logand modifier-code (ash 1 j)) 0))
                            (setq mod-face (alist-get (+ (* face-idx
                                                            (length modifier-faces))
                                                        j)
                                                        pair-faces
                                                        (aref modifier-faces j)))
                            (push mod-face faces-to-apply)))
                   (puthash modifier-code faces-to-apply semantic-token-modifier-cache))
                 (dolist (face faces-to-apply)
                   (add-face-text-property text-property-beg text-property-end face)))
               when (> current-line line-max-inclusive) return nil)))))
      `(jit-lock-bounds ,beg . ,end)))))
#+end_src

Now we replace =lsp-mode='s default implementation with our own.

#+begin_src emacs-lisp
;;(advice-add 'lsp-semantic-tokens--fontify :override
;;            #'+lsp-semantic-tokens--fontify-with-pairs)
#+end_src

*** Code Lens
#+begin_src emacs-lisp
(setq lsp-lens-place-position 'above-line)
#+end_src

*** UI

Prefer thing at-point than in the sideline (conflicts with Inlay Hints).

#+begin_src emacs-lisp
(setq lsp-ui-sideline-enable nil
      lsp-ui-peek-enable t
      lsp-ui-imenu-kind-position 'left
      lsp-ui-doc-max-height 30)
#+end_src

*** Disable Servers

#+begin_src emacs-lisp
(setq lsp-disabled-clients '((typescript-mode . deno)))
#+end_src

* Appearance
** Text
*** Constants

First, some sizes.

#+begin_src emacs-lisp
(defconst *line-spacing* 0.25)

(defconst *text-font-height* (1- (string-to-number (getenv "EMACS_TEXT_FONT_SIZE"))))
(defconst *ui-font-height* (string-to-number (getenv "EMACS_UI_FONT_SIZE")))
#+end_src

Now, the fonts we will use. These are passed via environment variables
via our Nix module.

#+begin_src emacs-lisp
(defconst *fixed-pitch-font* (getenv "EMACS_MONO_FONT_FAMILY")
    "Font used for monospaced text.")

(defconst *variable-pitch-font* (getenv "EMACS_VARIABLE_PITCH_FONT_FAMILY")
    "Font used for variable text.")

(defconst *serif-font* (getenv "EMACS_SERIF_FONT_FAMILY")
    "Font used for serif text.")

(defconst *unicode-font* (getenv "EMACS_UNICODE_FONT_FAMILY")
    "Font used to display unicode symbols.")
#+end_src

*** Font faces
Let's start changing the global Doom font faces.

#+begin_src emacs-lisp
(setq doom-font (font-spec :family *fixed-pitch-font* :size *text-font-height*)
      doom-variable-pitch-font (font-spec :family *variable-pitch-font* :size *text-font-height*)
      doom-serif-font (font-spec :family *serif-font* :size *text-font-height*)
      doom-unicode-font (font-spec :family *unicode-font* :size *text-font-height*)
      doom-font-increment 1)
#+end_src

Now, the modeline:

#+begin_src emacs-lisp
(custom-set-faces
  `(mode-line ((t (:font ,doom-variable-pitch-font)))))
#+end_src

~org-mode~...

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2)
  '(org-level-1 :weight extra-bold :height 1.45)
  '(org-level-2 :weight bold :height 1.35)
  '(org-level-3 :weight bold :height 1.2)
  '(org-level-4 :weight semi-bold :height 1.00)
  '(org-level-5 :weight semi-bold :height 1.00)
  '(org-level-6 :weight semi-bold :height 1.00)
  '(org-level-8 :weight semi-bold)
  '(org-level-9 :weight semi-bold))

;; Make quotes and verses italic
(setq org-fontify-quote-and-verse-blocks t)
#+end_src
*** Line length/spacing

#+begin_src emacs-lisp
(setq-default fill-column 90)
(setq-default line-spacing *line-spacing*)
#+end_src

*** Underline

Underline at a descent position, not baseline position.

#+begin_src emacs-lisp
(setq x-underline-at-descent-line t)
#+end_src

*** Mixed Pitch
In some modes (like ~org-mode~), we would like to use mixed pitch. To do this, we
need to add a hook that runs /after/ the UI is initialized.

#+begin_src emacs-lisp
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
    "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")

(defun init-mixed-pitch-h ()
    "Hook `mixed-pitch-mode' into each mode in `mixxed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of those."
    (when (memq major-mode mixed-pitch-modes)
        (mixed-pitch-mode 1))
    (dolist (hook mixed-pitch-modes)
        (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))

(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

** Layout
*** Frame

See Frame Layout documentation for details and terminology.

- Add some padding around the whole window (~internal-border-width~) to provide
  some air.
- Remove GUI elements.
- Make the title-bar transparent on macOS.

#+begin_src emacs-lisp
(when *is-macos*
  (setq frame-title-format nil)
  (dolist (filter '((ns-transparent-titlebar . t)
                    (ns-appearance . unbound)))
    (cl-pushnew filter default-frame-alist :test #'equal)))
#+end_src

*** Padding

Add margins inside windows to make text fell less crowded. Padding around the frame
is configured via the ~internal-border-width~ in the Frame section.

#+begin_src emacs-lisp
(setq-default left-margin-width 1
              right-margin-width 1)
#+end_src

** Interface
*** Number line
#+begin_src emacs-lisp
(setq display-line-numbers-type 'visual)
#+end_src

*** Disable =hl-line-mode=

#+begin_src emacs-lisp
(setq global-hl-line-mode '())
#+end_src

** Theme
*** =font-lock= faces customization
The default faces for =doom-horizon= is nice, but we need to change a few things.

Beginning with documentation and comments, they should be in italics.
#+begin_src emacs-lisp
(custom-theme-set-faces! 'doom-horizon
  `(font-lock-doc-face
    :slant italic
    :foreground ,(doom-color 'doc-comments))
  `(font-lock-comment-face
    :slant italic
    :foreground ,(doom-color 'comments)))
#+end_src

Now some tokens.
#+begin_src emacs-lisp
(custom-theme-set-faces! 'doom-horizon
  `(font-lock-string-face
    :foreground ,(doom-darken (doom-color 'green) 0.1))
  `(font-lock-variable-name-face
    :foreground ,(doom-color 'fg))
  ;; We will need to adjust the & operator later in the Tree-Sitter config.
  `(tree-sitter-hl-face:operator
    :foreground ,(doom-color 'fg))
      )
#+end_src

*** =tree-sitter= faces customization
Doom pins =tree-sitter= packages, let's live on the edge!

#+begin_src emacs-lisp :tangle packages.el
(package! tree-sitter :pin nil)
(package! tree-sitter-langs :pin "1076cf2366be8ef1bd6fd7239f92f16cc0890fce")
#+end_src

Now, let's define faces that are missing from the upstream package.

**** LSP Semantic Tokens Faces

#+begin_src emacs-lisp
(defface tree-sitter-hl-face:namespace
  '((default :inherit default))
  "Face used for namespaces/modules.")

(defface tree-sitter-hl-face:namespace.builtin
  '((default :inherit tree-sitter-hl-face:namespace))
  "Face used for a built-in namespace.")

(defface tree-sitter-hl-face:class
  '((default :inherit tree-sitter-hl-face:type))
  "Face used for class names.")

(defface tree-sitter-hl-face:enum
  '((default :inherit tree-sitter-hl-face:type))
  "Face used for enum names.")

(defface tree-sitter-hl-face:interface
  '((default :inherit tree-sitter-hl-face:type))
  "Face used for interface names.")

(defface tree-sitter-hl-face:struct
  '((default :inherit tree-sitter-hl-face:class))
  "Face used for struct names.")

(defface tree-sitter-hl-face:enum.member
  '((default :inherit tree-sitter-hl-face:property))
  "Face used for enum members.")

(defface tree-siter-hl-face:modifier
  '((default :inherit tree-sitter-hl-face:keyword))
  "Face used for keyword modifiers.")

(defface tree-sitter-hl-face:decorator
  '((default :inherit tree-sitter-hl-face:function.call))
  "Face used for decorators.")

(defface tree-sitter-hl-face:operator
  '((default :inherit default))
  "Face used for operators.")

(defface tree-sitter-hl-face:static
  '((default :weight semi-bold))
  "Face used for static members.")

(defface tree-sitter-hl-face:deprecated
  '((default :strike-through t))
  "Face used for deprecated elements.")
#+end_src

**** Rust Analyzer Semantic Tokens Faces
Although most tokens in RA can use pre-defined faces, some need extra faces. We
define these here as we can also use it for other languages.

#+begin_src emacs-lisp
(defface tree-sitter-hl-face:unresolved
  `((default
      :inherit default
      :background ,(doom-blend (doom-color 'bg)
                               (doom-color 'red)
                               0.6)))
  "Face used for unresolved references.")

(defface tree-sitter-hl-face:function.mutable
  '((default :inherit tree-sitter-hl-face:variable.special))
  "Face used for functions that mutate arguments.")

(defface tree-sitter-hl-face:variable.mutable
  '((default :inherit tree-sitter-hl-face:variable :underline t))
  "Face used for mutable variables.")

(defface tree-sitter-hl-face:namespace.root
  '((default :inherit tree-sitter-hl-face:namespace))
  "Face used for the root of a namespace.")

(defface tree-sitter-hl-face:type.lifetime
  '((default :inherit tree-sitter-hl-face:string))
  "Face used for lifetimes.")

(defface tree-sitter-hl-face:function.async
  '((default :inherit tree-sitter-hl-face:function.call))
  "Face used for async functions.")

(defface tree-sitter-hl-face:variable.callable
  '((default :inherit tree-sitter-hl-face:variable))
  "Face used for variables that can be called as a function.")

(defface tree-sitter-hl-face:rust.unsafe
  `((default :foreground ,(doom-color 'red) :slant italic))
  "Face used for unsafe operations.")

(defface tree-sitter-hl-face:union
  '((default :inherit tree-sitter-hl-face:type))
  "Face used for union types.")

(defface tree-sitter-hl-face:type.alias
  '((default :inherit tree-sitter-hl-face:type))
  "Face used for type aliases.")

(defface tree-sitter-hl-face:boolean
  '((default :inherit tree-sitter-hl-face:number))
  "Face used for booleans.")

(defface tree-sitter-hl-face:operator.logical
  '((default :inherit tree-sitter-hl-face:operator))
  "Face used for logical operators.")

(defface tree-sitter-hl-face:variable.consuming
  `((default
      :inherit tree-sitter-hl-face:variable
      :foreground ,(doom-darken (doom-color 'fg) 0.2)
      :slant italic))
  "Face used for variables being consumed by a function call.")

(defface tree-sitter-hl-face:variable.parameter.consuming
  `((default
      :inherit tree-sitter-hl-face:variable.parameter
      :foreground ,(doom-darken (doom-color 'fg) 0.2)
      :slant italic))
  "Face used for variables being consumed by a function call.")
#+end_src

*** =lsp-semantic= faces customization
Being honest, the default ~lsp-face-semhl-*~ faces /suck/, period. With almost all
themes that I tested, everything is only two colors! This part of the configuration
tries to fix this issue.

=lsp-mode= requires all legends to be defined in ~lsp-semantic-token-faces~ and
in ~lsp-semantic-token-modifier-faces~ to be recognized. As our hack to implement
composite matching uses face equality, we need to define placeholders for all legends that
we only use in these matches.

#+begin_src emacs-lisp
(defface placeholder-face:declaration '() "")
(defface placeholder-face:definition '() "")
(defface placeholder-face:readonly '() "")
(defface placeholder-face:static '() "")
(defface placeholder-face:abstract '() "")
(defface placeholder-face:async '() "")
(defface placeholder-face:modification '() "")
(defface placeholder-face:default-library '() "")

(defface placeholder-face:ra-attribute '() "")
(defface placeholder-face:ra-callable '() "")
(defface placeholder-face:ra-constant '() "")
(defface placeholder-face:ra-consuming '() "")
(defface placeholder-face:ra-control-flow '() "")
(defface placeholder-face:ra-crate-root '() "")
(defface placeholder-face:ra-intra-doc-link '() "")
(defface placeholder-face:ra-library '() "")
(defface placeholder-face:ra-mutable '() "")
(defface placeholder-face:ra-public '() "")
(defface placeholder-face:ra-reference '() "")
(defface placeholder-face:ra-trait '() "")
#+end_src

Now, let's make =lsp-mode= use new faces for tokens.

#+begin_src emacs-lisp
(setq-default lsp-semantic-token-faces
        '( ;; Built-in LSP tokens
        ("namespace" . tree-sitter-hl-face:namespace)
        ("type" . tree-sitter-hl-face:type)
        ("class" . tree-sitter-hl-face:class)
        ("enum" . tree-sitter-hl-face:enum)
        ("interface" . tree-sitter-hl-face:interface)
        ("struct" . tree-sitter-hl-face:struct)
        ("typeParameter" . tree-sitter-hl-face:type.parameter)
        ("paramenter" . tree-sitter-hl-face:variable.parameter)
        ("variable" . tree-sitter-hl-face:variable)
        ("property" . tree-sitter-hl-face:property)
        ("enumMember" . tree-sitter-hl-face:enum.member)
        ("function" . tree-sitter-hl-face:function.call)
        ("method" . tree-sitter-hl-face:method.call)
        ("macro" . tree-sitter-hl-face:function.macro)
        ("keyword" . tree-sitter-hl-face:keyword)
        ("modifier" . tree-sitter-hl-face:modifier)
        ("comment" . tree-sitter-hl-face:comment)
        ("string" . tree-sitter-hl-face:string)
        ("number" . tree-sitter-hl-face:number)
        ("regexp" . tree-sitter-hl-face:string.special)
        ("operator" . tree-sitter-hl-face:operator)
        ("decorator" . tree-sitter-hl-face:decorator)
        ("label" . tree-sitter-hl-face:label)

        ;; Rust-Analyzer extras
        ("derive" . tree-sitter-hl-face:function.macro)
        ("typeAlias" . tree-sitter-hl-face:type.alias)
        ("union" . tree-sitter-hl-face:union)
        ("boolean" . tree-sitter-hl-face:boolean)
        ("character" . tree-sitter-hl-face:string)
        ("escapeSequence" . tree-sitter-hl-face:escape)
        ;; TODO create a new face for this?
        ("formatSpecifier" . tree-sitter-hl-face:string.special)
        ("logical" . tree-sitter-hl-face:operator.logical)
        ("macroBang" . tree-sitter-hl-face:function.macro)
        ("builtinAttribute" . tree-sitter-hl-face:function.builtin)
        ("builtinType" . tree-sitter-hl-face:type.builtin)
        ("constParameter" . tree-sitter-hl-face:constant)
        ("lifetime" . tree-sitter-hl-face:type.lifetime)
        ("selfKeyword" . tree-sitter-hl-face:keyword)
        ("selfTypeKeyword" . tree-sitter-hl-face:keyword)
        ("unresolvedReference" . tree-sitter-hl-face:unresolved)))
#+end_src

Followed by setting new faces for modifiers. Note that we use our ~placeholder-face:*~
to define new modifiers that doesn't have specific styles.

#+begin_src emacs-lisp
(setq-default lsp-semantic-token-modifier-faces
        '( ;; Built-in LSP modifiers (most omitted).
        ("declaration" . placeholder-face:declaration)
        ("definition" . placeholder-face:definition)
        ("readonly" . placeholder-face:readonly)
        ("static" . placeholder-face:static)
        ("deprecated" . tree-sitter-hl-face:deprecated)
        ("abstract" . placeholder-face:abstract)
        ("async" . placeholder-face:async)
        ("modification" . placeholder-face:modification)
        ("documentation" . tree-sitter-hl-face:doc)
        ("defaultLibrary" . placeholder-face:default-library)

        ;; Rust-Analyzer extras
        ("crateRoot" . tree-sitter-hl-face:namespace.root)
        ("unsafe" . tree-sitter-hl-face:rust.unsafe)
        ("injected" . tree-sitter-hl-face:embedded)
        ("attribute". placeholder-face:ra-attribute)
        ("callable" . placeholder-face:ra-callable)
        ("constant" . placeholder-face:ra-constant)
        ("consuming" . placeholder-face:ra-consuming)
        ("controlFlow" . placeholder-face:ra-control-flow)
        ("intraDocLink" . placeholder-face:ra-intra-doc-link)
        ("library" . placeholder-face:ra-library)
        ("mutable" . placeholder-face:ra-mutable)
        ("public" . placeholder-face:ra-public)
        ("reference" . placeholder-face:ra-reference)
        ("trait" . placeholder-face:ra-trait)))
#+end_src

*** Enable theme
Now we can set the theme.

#+begin_src emacs-lisp
(setq doom-theme 'doom-horizon)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src

** Org
There is a bunch of stuff here, so let's get going!

*** Symbols
Replace some commands and checkboxes with Unicode stuff :blush:

#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src

*** Remove =hl-line-mode=

With our current mixed pitch setup for =org-mode=,  having the line highlighting
looks weird, so we need to disable it.

#+begin_src emacs-lisp
(add-hook! 'org-mode-hook (hl-line-mode -1))
#+end_src

** Splash Screen
Emacs can render an image as the splash screen, I kindly /borrowed/ the custom Emacs E
from [[https://tecosaur.github.io/emacs-config/config.html#splash-screen][@tecosaur]]'s configuration :speak-no-evil:.

Just make it theme-appropriate and follow the frame size. One thing that I needed
to change in the original configuration is that the SVG wasn't scaling properly.

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-viewbox-size (height)
  "Compute the size necessary to fit the image with height HEIGHT."
  (let ((vb-width (ceiling (* 0.80378 (float height))))
        (vb-height (+ height 7)))
    (message "vb-width: %s" (type-of vb-width))
    (message "vb-height: %s" (type-of vb-height))
    `(("$vbWidth" . ,vb-width) ("$vbHeight" . ,vb-height))))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (goto-char (point-min))
    (re-search-forward "$scale" nil t)
    (replace-match (number-to-string (/ height 107)) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

I really don't use the dashboard commands, so let's remove them! While we're at it,
let's also remove the modeline, ~hl-line-mode~, and the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

Following our borrowing strategy, let's also add a phrase to the dashboard.

#+begin_src emacs-lisp
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")

(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")

(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")

(defun splase-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defvar splase-phrase--cache nil)

(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splase-phrase--cache))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splase-phrase--cache)))))
    (nth (random (length lines)) lines)))

(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))

(defun doom-dashboard-phrase ()
  "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

** Popup rules

#+begin_src emacs-lisp
(set-popup-rules!
  '(("^\\*info\\*"
     :slot 2 :side left :width 83 :quit nil)
    ("^\\*\\(?:Wo\\)?Man "
     :vslot -6 :size 0.45 :select t :quit nil :ttl 0)
    ("^\\*ielm\\*$"
     :vslot 2 :size 0.4 :quit nil :ttl nil)
    ("^\\*Ilist\\*$"
     :slot 2 :side left :size 0.3 :quit nil :ttl nil)
    ;; `help-mode', `helpful-mode'
    ("^\\*[Hh]elp"
     :slot 2 :vslot -8 :size 0.45 :select t)
    ("^\\*Checkdoc Status\\*$"
     :vslot -2 :select ignore :quit t :ttl 0)
    ("^\\*\\(?:[Cc]ompil\\(?:ation\\|e-Log\\)\\|Messages\\)"
     :slot -2 :size 0.45 :side right :autosave t :quit current :ttl nil
     :modeline t)
    ("^ \\*\\(?:undo-tree\\|vundo tree\\)\\*"
     :slot 2 :side left :size 20 :select t :quit t)
    ("^\\*\\(?:doom \\|Pp E\\)"  ; transient buffers (no interaction required)
     :vslot -3 :size +popup-shrink-to-fit :autosave t :select ignore :quit t :ttl 0)
    ("^\\*Backtrace" :vslot 99 :size 0.4 :quit nil)
    ("^\\*\\(?:Proced\\|timer-list\\|Process List\\|Abbrevs\\|Output\\|Occur\\|unsent mail\\)\\*" :ignore t)
    ("^\\*Flycheck errors\\*$"
     :vslot -2 :select t :quit t :ttl 0)))
#+end_src

* Languages
** Protocol Buffers

Add syntax highlighting to =.proto= files.

#+begin_src emacs-lisp :tangle "packages.el"
(package! protobuf-mode)
#+end_src

** Rust
*** Custom Semantic Tokens

#+begin_src emacs-lisp
(let* ((token-faces (default-value 'lsp-semantic-token-faces))
       (token-face (lambda (tok) (cdr (assoc tok token-faces))))
       (injected-token (lambda (tok) `("injected" . ,(funcall token-face tok))))
       (inj-token (lambda (tok) `(,tok ,(funcall injected-token tok)))))
  (setf (alist-get #'rustic-mode
                   lsp-semantic-token-modifier-pair-faces)
        `(,(funcall inj-token "namespace")
          ,(funcall inj-token "type")
          ,(funcall inj-token "class")
          ,(funcall inj-token "enum")
          ,(funcall inj-token "interface")
          ,(funcall inj-token "struct")
          ,(funcall inj-token "typeParameter")
          ("parameter"
            ("mutable" . tree-sitter-hl-face:variable.mutable)
            ("consuming" . tree-sitter-hl-face:parameter.consuming)
            ,(funcall injected-token "parameter"))
          ("variable"
            ("mutable" . tree-sitter-hl-face:variable.mutable)
            ("callable" . tree-sitter-hl-face:variable.callable)
            ("consuming" . tree-sitter-hl-face:variable.consuming)
            ,(funcall injected-token "variable"))
          ,(funcall inj-token "property")
          ,(funcall inj-token "enumMember")
          ("function"
            ("mutable" . tree-sitter-hl-face:function.mutable)
            ("async" . tree-sitter-hl-face:function.async)
            ("unsafe" . tree-sitter-hl-face:rust.unsafe)
            ,(funcall injected-token "function"))
          ("method"
            ("mutable" . tree-sitter-hl-face:function.mutable)
            ("async" . tree-sitter-hl-face:function.async)
            ("unsafe" . tree-sitter-hl-face:rust.unsafe)
            ,(funcall injected-token "method"))
          ,(funcall inj-token "macro")
          ,(funcall inj-token "keyword")
          ,(funcall inj-token "modifier")
          ,(funcall inj-token "comment")
          ,(funcall inj-token "string")
          ,(funcall inj-token "regexp")
          ,(funcall inj-token "operator")
          ,(funcall inj-token "decorator")
          ,(funcall inj-token "label")
          ,(funcall inj-token "derive")
          ,(funcall inj-token "typeAlias")
          ,(funcall inj-token "union")
          ,(funcall inj-token "boolean")
          ,(funcall inj-token "character")
          ,(funcall inj-token "escapeSequence")
          ,(funcall inj-token "formatSpecifier")
          ,(funcall inj-token "operator")
          ,(funcall inj-token "arithmetic")
          ,(funcall inj-token "bitwise")
          ,(funcall inj-token "comparison")
          ,(funcall inj-token "logical")
          ,(funcall inj-token "punctuation")
          ,(funcall inj-token "attributeBracket")
          ,(funcall inj-token "angle")
          ,(funcall inj-token "brace")
          ,(funcall inj-token "bracket")
          ,(funcall inj-token "parenthesis")
          ,(funcall inj-token "colon")
          ,(funcall inj-token "dot")
          ,(funcall inj-token "semi")
          ,(funcall inj-token "macroBang")
          ,(funcall inj-token "builtinAttribute")
          ,(funcall inj-token "builtinType")
          ,(funcall inj-token "constParameter")
          ,(funcall inj-token "enumMember")
          ,(funcall inj-token "generic")
          ,(funcall inj-token "lifetime")
          ,(funcall inj-token "selfKeyword")
          ,(funcall inj-token "selfTypeKeyword")
          ,(funcall inj-token "toolModule")
          ,(funcall inj-token "unresolvedReference"))))
#+end_src

*** Rust-Analyzer config

#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-rust-analyzer-server-display-inlay-hints t
        lsp-rust-analyzer-display-chaining-hints t
        lsp-rust-analyzer-display-closure-return-type-hints t
        lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial"
        lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t
        lsp-rust-analyzer-display-parameter-hints t
        lsp-rust-analyzer-display-reborrow-hins t
        lsp-rust-analyzer-hide-clsoure-initialization t
        lsp-rust-analyzer-cargo-watch-command "clippy"))
#+end_src

** YAML
*** LSP Settings
#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-yaml-schema-store-local-db (f-join doom-cache-dir "lsp" "lsp-yaml-schemas.json")))
#+end_src

** Coq

Change how Proof General shows executed proofs.

#+begin_src emacs-lisp
(custom-set-faces!
  `(proof-locked-face :background ,(doom-blend (doom-color 'bg)
                                               (doom-color 'green)
                                               0.95)))
#+end_src

If =corfu= is enabled, translate =company-coq= backends to it.

#+begin_src emacs-lisp
(when (featurep! :completion corfu)
  (add-hook! proof-mode
    (setq completion-at-point-functions
          (mapcar #'cape-company-to-capf
                  (list #'company-coq-reserved-keywords-backend
                        #'company-coq-block-end-backend
                        #'company-coq-modules-backend
                        #'company-coq-context-backend
                        #'company-coq-refman-tactic-abbrevs-backend
                        #'company-coq-pg-backend
                        #'company-coq-local-definitions-backend
                        #'company-coq-dynamic-tactics-backend
                        #'company-coq-dynamic-symbols-backend)))))
#+end_src

** Zig

#+begin_src emacs-lisp
(use-package! zig-mode
  :init
  (add-hook 'zig-mode-hook #'tree-sitter!)
  (add-hook 'zig-mode-hook #'lsp! 'append))
#+end_src

* Tools
** Bazel
*** =bazel-mode=
It has awesome Emacs support with =bazel-mode=, let's install it.

#+begin_src emacs-lisp :tangle packages.el
(package! bazel
          :recipe (:host github
                   :repo "bazelbuild/emacs-bazel-mode"
                   :files ("bazel.el")))
#+end_src

Now we configure it.

#+begin_src emacs-lisp
(use-package! bazel
  :config
  (setq bazel-buildifier-before-save t
        bazel-fix-visibility 'ask))
#+end_src

*** Tree-Sitter support

Starklark doesn't have a tree-sitter grammar yet, but it doesn't need to, as we
can use the Python grammar instead.

#+begin_src emacs-lisp
(defadvice! bazel-tree-sitter (&rest _)
  :after 'tree-sitter--setup
  (dolist (entry '((bazel-build-mode . python)
                               (bazel-workspace-mode . python)))
                (cl-pushnew entry tree-sitter-major-mode-language-alist
                            :key #'car)))
#+end_src

Now, we need to let Tree-Sitter know of Starlark native API and also native Bazel
targets for =BUILD= files.

#+begin_src emacs-lisp
(add-hook! bazel-build-mode
           (tree-sitter-hl-add-patterns nil
             [;; Android rules
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                        "^android_(binary|library|(instrumentation|local)_test|device)$")))
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin "^aar_import$")))
              ;; C/C++ rules
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                        "^cc_(binary|import|(proto_)?library|test)$")))
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                        "^fdo_(prefetch_hints|profile)$")))
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                        "^propeller_optimize$")))
              ;; Java Rules
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                        "^java_(binary|import|((lite_)?proto_)?library|test|plugin|runtime)$")))
              ;; Objetive-C
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                 "^(apple_static|(j2)?objc)_library|objc_import|available_xcodes|xcode_(config|version)$")))
              ;; Shell
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                 "^sh_(binary|library|test)$")))
              ;; Language agnostic rules
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                 "^action_listener|extra_action|alias|config_setting|filegroup|gen(query|rule)|test_suite$")))
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                 "^constraint_(setting|value)|platform|toolchain(_type)?$")))

              ;; Native API
              ;; native names
              ((call function: (identifier) @function.builtin
                (.match? @function.builtin
                 "^existing_rules?|exports_files|glob|package_(group|name)|repository_name|subpackages$")))
              ((call function: [
                attribute
                  object: (identifier) @variable.builtin
                  (.match? @variable.builtin "^native|json$")]))
              ]))
#+end_src

Now we deal with =WORKSPACE= files.

#+begin_src emacs-lisp
(add-hook! bazel-workspace-mode
           (tree-sitter-hl-add-patterns nil
             [((call function: (identifier) @function.builtin
                (.match? @function.builtin "^bind|(new_)?local_repository$")))]))
#+end_src

We'll ignore ~*.bzl~ files for now, as listing the entire native API will be a PITA.

** Terraform
*** LSP Settings

#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-terraform-ls-enable-show-reference t))
#+end_src

*** Tree Sitter

Enable tree-sitter highlighting:

#+begin_src emacs-lisp
(add-hook! terraform-mode :append #'tree-sitter-hl-mode)
#+end_src

Extra patterns:

#+begin_src emacs-lisp
(add-hook! terraform-mode :append
  (tree-sitter-hl-add-patterns nil
    [((identifier) @type (.match? @type "^(string|number|bool)$"))
     (function_call (identifier) @type (.match? @type "^(list|map|set|object|tuple)$"))]))

#+end_src

** Magit

*** Granular diffs

#+begin_src emacs-lisp
(after! magit
  (setq magit-diff-refine-hunk 'all))
#+end_src

*** Use =delta= for diff highlighting

#+begin_src emacs-lisp :tangle packages.el
(package! magit-delta)
#+end_src

#+begin_src emacs-lisp
(use-package magit-delta
  :hook (magit-mode . magit-delta-mode))
#+end_src


** Nix

*** LSP

#+begin_src emacs-lisp
(use-package! lsp-nix
  :after lsp-mode)
#+end_src

*** Tree Sitter

#+begin_src emacs-lisp
(add-hook! nix-mode :append
  (tree-sitter-hl-add-patterns nil
    [((app (identifier) @function.call .))
     ((select (identifier) @variable
              (attrpath (attr_identifier)+ @property)))
     ((attrpath (attr_identifier) @variable
                (attr_identifier)* @property))]))
#+end_src
